#!/bin/sh
#------------------------------------------------------------------------------
#	ПАКЕТ КВАС
#------------------------------------------------------------------------------
#
#	Данный файл служит библиотекой переменных среды и функций,
#	которые используются в событийном пакете ndm
#	https://github.com/ndmsystems/packages/wiki/Opkg-Component
#
# ------------------------------------------------------------------------------
#	Разработчик: mail@zeleza.ru
#	Дата создания: 13/09/2022
#	Лицензия: GPL 2.0
# ------------------------------------------------------------------------------------------

app="КВАС"
# имя таблицы для ipset
table_name=unblock

TABLE_ID=1001
PRIORITY=1778
MARK_NUM=0xd1000
DNS_PORT=53

INFACE_CLI=@CLI_INFACE_NAME
INFACE_ENT=@ENTWARE_INFACE_NAME

#как пример гостевая сеть br3, которой необходимо обеспечить доступ к VPN
INFACE_GUEST_ENT=
# Файл в котором содержатся сети, запросы из которых необходимо исключить
# из обращений к VPN или SHADOWSOCKS подключениям
EXCLUDED_NET_FILE=/opt/apps/kvas/etc/conf/excluded.net
# Метка VPN цепочки для правил iptables
VPN_IPTABLES_CHAIN=VPNREDIR
# Метка SHADOWSOCKS цепочки для правил iptables
SSR_IPTABLES_CHAIN=SHADOWSOCKS


# ------------------------------------------------------------------------------------------
# Подключаем функции логирования
. /opt/apps/kvas/bin/libs/logging
# ------------------------------------------------------------------------------------------

ip4() (/opt/sbin/ip -4 "$@")
ip4tables() (if ! /opt/sbin/iptables -C "$@" &>/dev/null; then /opt/sbin/iptables -A "$@"; fi)
ipXtables() (/opt/sbin/iptables "$@")
ip4save() (/opt/sbin/iptables-save)
get_gw4()(ip4 addr show "${1}" | grep -Po "(?<=inet ).*(?=/)")

INFACE_GW4=$(get_gw4 "${INFACE_ENT}")

# в случае если задан гостевой интерфейс
[ -n "${INFACE_GUEST_ENT}" ] && {
	INFACE_GUEST_GW4=$(get_gw4 "${INFACE_GUEST_ENT}")
	GUEST_NET="$(echo "${INFACE_GUEST_GW4}" | cut -d'.' -f1-3).0/24"
}

# ------------------------------------------------------------------------------------------
# проверка на доступность программного и аппаратного ускорения
# ------------------------------------------------------------------------------------------
fastnet_support()(curl -s localhost:79/rci/show/version | grep -q ppe)
fast_hw_enabled()(! curl -s localhost:79/rci/show/rc/ppe | grep hardware -C1 | grep -q false)
fast_sw_enabled()(! curl -s localhost:79/rci/show/rc/ppe | grep software -C1 | grep -q false)
fastnet_enabled()(fast_hw_enabled || fast_sw_enabled)
# ------------------------------------------------------------------------------------------

ip4_flush_cache(){
	ip4 route flush cache > "${res_file}"
	log_when_error "${?}" "${app}::Очистка кеша маршрутизации"
}
# ------------------------------------------------------------------------------------------

ip4_firewall_dns_rules_set(){
	inface="${1}"
	local_ip=${2}
	protocol=${3}
	# если правила для tcp есть, то пропускаем их добавление
	if ! ip4save | grep -q "${protocol} \-\-dport ${DNS_PORT} \-j DNAT"; then
		ip4tables PREROUTING -w -t nat -i ${inface} -p ${protocol} --dport ${DNS_PORT} -j DNAT --to ${local_ip}
	fi
}
# ------------------------------------------------------------------------------------------
# Исключаем из работы локальные запросы
# ------------------------------------------------------------------------------------------
ip4_firewall_exclude_locals(){
	chain_name=${1}; type=${2};
	while read -r _net || [ -n "${_net}" ]; do
		#  пропускаем строки с комментариями
		[ "${_net:0:1}" = "#" ] && continue
		# удаляем из строк комментарии - все что встречается после символа # и сам символ
		_net=$(echo "${_net}" | sed 's/#.*$//g' | tr -s ' ' )
	  ip4tables ${chain_name} -t ${type} -d ${_net} -j RETURN

	done < "$EXCLUDED_NET_FILE}"
}
# ------------------------------------------------------------------------------------------
# Маркировка VPN подключений когда программное и аппаратное ускорение ПОДКЛЮЧЕНО
# ------------------------------------------------------------------------------------------
ip4_firewall_vpn_mark(){
	if ! ip4save | grep -q "${VPN_IPTABLES_CHAIN}" ; then
		# Маркируем трафик для домашней(основной) сети и прохождение пакетов через VPN подключение
		{
			ipХtables -N ${VPN_IPTABLES_CHAIN} -t mangle
			ip4tables ${VPN_IPTABLES_CHAIN} -t mangle -m set ! --match-set "${table_name}" dst -j RETURN

			# Игнорируем локальные сети и любые другие адреса, которые вы хотели бы обойти прокси
			ip4_firewall_exclude_locals ${VPN_IPTABLES_CHAIN} mangle

			ip4tables ${VPN_IPTABLES_CHAIN} -t mangle -j CONNMARK --restore-mark
			ip4tables ${VPN_IPTABLES_CHAIN} -t mangle -m mark --mark ${MARK_NUM} -j RETURN
			ip4tables ${VPN_IPTABLES_CHAIN} -t mangle -p tcp --syn -j MARK --set-mark ${MARK_NUM}
			ip4tables ${VPN_IPTABLES_CHAIN} -t mangle -p udp -m conntrack --ctstate NEW -j MARK --set-mark ${MARK_NUM}
			ip4tables ${VPN_IPTABLES_CHAIN} -t mangle -j CONNMARK --save-mark

			ip4tables PREROUTING -t mangle -p tcp -m set --match-set "${table_name}" dst -j ${VPN_IPTABLES_CHAIN}
			ip4tables PREROUTING -t mangle -p udp -m set --match-set "${table_name}" dst -j ${VPN_IPTABLES_CHAIN}
			ip4tables OUTPUT     -t mangle -p tcp -m set --match-set "${table_name}" dst -j ${VPN_IPTABLES_CHAIN}
			ip4tables OUTPUT     -t mangle -p udp -m set --match-set "${table_name}" dst -j ${VPN_IPTABLES_CHAIN}

		} 2> "${res_file}"
		log_when_error "${?}" "${app}::Маркировка трафика для VPN соединений"

#		ip4tables PREROUTING -t mangle -m conntrack --ctstate NEW -m set --match-set "${table_name}" dst -j CONNMARK --set-mark ${MARK_NUM} 2>"${res_file}"
#		ip4tables PREROUTING -t mangle -j CONNMARK --restore-mark >> "${res_file}"
		#[ -f "${res_file}" ] && [ "$(cat < "${res_file}" | wc -l )" -ge 1 ] && {
		#}

	fi
}
# ------------------------------------------------------------------------------------------
# Удаляем VPN правила для случая когда программное и аппаратное ускорение ПОДКЛЮЧЕНО
# ------------------------------------------------------------------------------------------
ip4_firewall_fastnet_vpn_prune(){
	num_lines=$(ipXtables -t mangle -L ${VPN_IPTABLES_CHAIN} --line-numbers 2>/dev/null | wc -l)
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(ipXtables -t mangle -L ${VPN_IPTABLES_CHAIN} --line-numbers \
					| cut -d" " -f1 \
					| head -1 \
					)
			/opt/sbin/iptables -t mangle -D ${VPN_IPTABLES_CHAIN} "${nline}" 2>"${res_file}"
		done
		log_when_error "${?}" "${app}::Очистка правил iptable для VPN подключения"

	else
		logger_dev "${app}::Правила iptable для VPN подключения отсутствуют."
	fi
}
# ------------------------------------------------------------------------------------------
# Удаляем VPN правила для случая когда программное и аппаратное ускорение ОТКЛЮЧЕНО
# ------------------------------------------------------------------------------------------
ip4_firewall_nofastnet_vpn_prune(){
	num_lines=$(ipXtables -t mangle -L PREROUTING --line-numbers  2>/dev/null  | grep CONNMARK | grep -cE "(${table_name}|restore-mark)")
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(ipXtables -t mangle -L PREROUTING --line-numbers \
					| grep CONNMARK \
					| grep -E "(${table_name}|restore-mark)" \
					| cut -d" " -f1 \
					| head -1 \
					)
			ipXtables -t mangle -D PREROUTING "${nline}" 2>"${res_file}"
		done
		log_when_error "${?}" "${app}::Очистка правил iptable для VPN подключения"

	else
		logger_dev "${app}::Правила iptable для VPN подключения отсутствуют."
	fi
}

# ------------------------------------------------------------------------------------------
# Маркировка VPN подключений когда программное и аппаратное ускорение ОТКЛЮЧЕНО
# ------------------------------------------------------------------------------------------
ip4_firewall_mark_rules_tcp_udp_on(){
	if ! ip4save | grep "\j MARK" | grep -q "${table_name}" ; then
		# Исключаем маркировку трафика для гостевой (в том числе) сети
		ip4tables PREROUTING -t mangle -i "${INFACE_GUEST_ENT}" -p tcp -m set --match-set ${table_name} dst -j MARK --set-mark ${MARK_NUM} 2>"${res_file}"
		ip4tables PREROUTING -t mangle -i "${INFACE_GUEST_ENT}" -p udp -m set --match-set ${table_name} dst -j MARK --set-mark ${MARK_NUM} 2>>"${res_file}"
		log_when_error "${?}" "${app}::Маркировка трафика гостевой сети для tcp или udp"
	fi
}
# ------------------------------------------------------------------------------------------

ip4_firewall_set_ssr_rules(){
	inface="${1}"
	proxy_port="${2}"

	# Источник:
	# https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-redir.asciidoc?ysclid=l949tgrsfn795375643
	# Создаем новую цепочку SHADOWSOCKS
	{
		ipXtables -N ${SSR_IPTABLES_CHAIN} -t nat
		ipXtables -N ${SSR_IPTABLES_CHAIN} -t mangle

		ssr_ip=$(cat < /opt/etc/shadowsocks.json | grep 'server":' | tr -d '" ,' | cut -d':' -f2 )
		# Исключаем любые обращения к собственному адресу SHADOWSOCKS
		ip4tables ${SSR_IPTABLES_CHAIN} -t nat -d ${ssr_ip} -j RETURN

		# Игнорируем локальные сети и любые другие адреса, которые вы хотели бы обойти прокси
		ip4_firewall_exclude_locals ${SSR_IPTABLES_CHAIN} nat

		# Anything else should be redirected to shadowsocks's local port
		ip4tables ${SSR_IPTABLES_CHAIN} -t nat -p tcp -j REDIRECT --to-ports "${proxy_port}"

		# Add any UDP rules
		ip4 route add local default dev ${inface} table ${table_name}
		ip4 rule add fwmark ${MARK_NUM} lookup ${table_name}
		ip4tables ${SSR_IPTABLES_CHAIN} -t mangle -p udp --dport ${DNS_PORT} -j TPROXY --on-port "${proxy_port}" --tproxy-mark ${MARK_NUM}/${MARK_NUM}

		# Apply the rules
		ip4tables PREROUTING -t nat -p tcp -j ${SSR_IPTABLES_CHAIN}
		ip4tables PREROUTING -t mangle -j ${SSR_IPTABLES_CHAIN}
echo 5
	} 2>"${res_file}"

	log_when_error "${?}" "${app}::Установка правил iptable для Shadowsocks подключения"

#	ip4tables PREROUTING -w -t nat -i ${inface} -p tcp -m set --match-set "${table_name}" dst -j REDIRECT --to-port ${proxy_port} 2>"${res_file}"

}
# ------------------------------------------------------------------------------------------
# Удаляем все правила iptables для SHADOWSOCKS подключений,
# которые были добавлены при работе пакета в старой редакции
# ------------------------------------------------------------------------------------------
ip4_firewall_ssr_prune(){

	num_lines=$(ipXtables -t nat -L ${SSR_IPTABLES_CHAIN} --line-numbers  2>/dev/null | wc -l )
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(ipXtables -t nat -L ${SSR_IPTABLES_CHAIN} --line-numbers \
					| cut -d" " -f1 \
					| head -1\
					)
			ipXtables -t nat -D ${SSR_IPTABLES_CHAIN} "${nline}" 2>"${res_file}"
		done
		log_when_error "${?}" "${app}::Очистка правил iptable для Shadowsocks подключения"
	else
		logger_dev "${app}::Правила iptable для Shadowsocks подключения отсутствуют."
	fi
}

# ------------------------------------------------------------------------------------------
# Удаляем все правила iptables для SHADOWSOCKS подключений,
# которые были добавлены при работе пакета в старой редакции
# ------------------------------------------------------------------------------------------
ip4_firewall_ssr_prune_old(){

	num_lines=$(ipXtables -t nat -L PREROUTING --line-numbers  2>/dev/null | grep -c "${table_name}")
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(ipXtables -t nat -L PREROUTING --line-numbers \
					| grep "${table_name}" \
					| cut -d" " -f1 \
					| head -1\
					)
			ipXtables -t nat -D PREROUTING "${nline}" 2>"${res_file}"
		done
		log_when_error "${?}" "${app}::Очистка правил iptable для Shadowsocks подключения"
	else
		logger_dev "${app}::Правила iptable для Shadowsocks подключения отсутствуют."
	fi
}
# ------------------------------------------------------------------------------------------
# Удаляем все правила iptables которые были добавлены при работе пакета
# ------------------------------------------------------------------------------------------
ip4_firewall_flush_all_rules(){
	ip4_firewall_fastnet_vpn_prune
	ip4_firewall_nofastnet_vpn_prune
	ip4_firewall_ssr_prune
#	ip4_firewall_ssr_prune_old
	[ "${INFACE_GUEST_ENT}" ] && ip4_del_guest_to_vpn_network
}
# ------------------------------------------------------------------------------------------

ip4_flush_all_tables(){

	ipset flush "${table_name}" 2>"${res_file}"
	log_when_error "${?}" "${app}::Очистка записей ipset таблицы ${table_name}"

	ip4 route flush table "${TABLE_ID}" > "${res_file}"
	log_when_error "${?}" "${app}::Очистка таблицы маршрутизации ID#${TABLE_ID}"

	ip4_flush_cache
}
# ------------------------------------------------------------------------------------------

ip4_add_route_table(){

	if [ -z "$(ip4 route show table ${TABLE_ID})" ]; then
		ip4 route add table ${TABLE_ID} default via ${INFACE_GW4} dev ${INFACE_ENT} 2>"${res_file}"
		log_when_error "${?}" "${app}::Созданеи таблицы маршрутизации ${TABLE_ID} для ${INFACE_CLI} интерфейса"
		ip4 route show table main |grep -Ev ^default | while read -r ROUTE; do ip4 route add table ${TABLE_ID} ${ROUTE} 2>"${res_file}"; done
		log_when_error "${?}" "${app}::Создание таблицы с ID#${TABLE_ID}"
	fi
}
# ------------------------------------------------------------------------------------------

ip4_rule_set_priority(){

	if ! ip4 rule show | grep -q "fwmark ${MARK_NUM} lookup ${TABLE_ID}"  ; then
		ip4 rule add fwmark ${MARK_NUM} lookup ${TABLE_ID} priority ${PRIORITY} 2>"${res_file}"
		log_when_error "${?}" "${app}::Установка приоритета таблицы с ID#${TABLE_ID} в значение ${PRIORITY}"
	fi

	ip4_flush_cache
}

ip4_rule_del_priority(){

	if ip4 rule show | grep -q "fwmark ${MARK_NUM} lookup ${TABLE_ID}"  ; then
		ip4 rule del fwmark ${MARK_NUM} lookup ${TABLE_ID} priority ${PRIORITY} 2>"${res_file}"
		log_when_error "${?}" "${app}::Обнуление приоритета таблицы с ID#${TABLE_ID}"
	fi

	ip4_flush_cache
}


# ------------------------------------------------------------------------------------------

ip4set_create_table(){
	if ipset list ${table_name} 2>&1 | grep -q 'name does not exist' ; then
		ipset create ${table_name} hash:net family inet -exist 2>"${res_file}"
		log_when_error "${?}" "${app}::Создание таблица с именем ${table_name} для ipset IPv4"
	fi
}
# ------------------------------------------------------------------------------------------

ip4_mark_vpn_network(){

	if fastnet_enabled ; then
		#logger_dev "${app}::Проверка пройдена -> программное и аппаратное ускорение ПОДКЛЮЧЕНО."
		# Без отключения ускорителей fastnat и hwnat
		ip4_firewall_vpn_mark
	else
		#logger_dev "${app}::Проверка пройдена -> программное и аппаратное ускорение ОТКЛЮЧЕНО!"
		# С отключением fastnat и ускорителей hwnat
		ip4_firewall_mark_rules_tcp_udp_on
	fi
#	в случае наличия гостевой сети
	if [ -n "${INFACE_GUEST_ENT}" ]; then
		ip4_add_guest_to_vpn_network
	fi
}
# ------------------------------------------------------------------------------------------
#
# 	Правила маркировки гостевого трафика
#
# ------------------------------------------------------------------------------------------
ip4_add_guest_to_vpn_network(){
	ip4save | grep "\-j MASQUERADE" | grep -q "${INFACE_GUEST_ENT}" && {
		# Маркируем трафик гостевой сети
		ip4tables PREROUTING -t nat -p udp -d "${INFACE_GUEST_GW4}" --dport ${DNS_PORT} -j DNAT --to "${INFACE_GW4}:53" 2>"${res_file}"
		ip4tables POSTROUTING -t nat -s "${GUEST_NET}" -o "${INFACE_GUEST_ENT}" -j MASQUERADE  2>>"${res_file}"
		log_when_error "${?}" "${app}::Маркировка гостевого трафика ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}]"
	}
}

# ------------------------------------------------------------------------------------------

ip4_flush_guest_preroute_rules (){
	num_lines=$(/opt/sbin/iptables -t nat -L PREROUTING --line-numbers | grep -c "${INFACE_GUEST_GW4}")
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(/opt/sbin/iptables -t nat -L PREROUTING --line-numbers \
					| grep "${INFACE_GUEST_GW4}" \
					| cut -d" " -f1 \
					| head -1 \
					)
			/opt/sbin/iptables -t nat -D PREROUTING "${nline}" 2>"${res_file}"
		done
		log_when_error "${?}" "${app}::Маркировка гостевого PREROUTING трафика ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}]"
	else
		logger_dev "${app}::Правила PREROUTING iptable для гостевой сети ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}] отсутствуют."
	fi
}
# ------------------------------------------------------------------------------------------

ip4_flush_guest_postroute_rules(){

	filter="$(echo ${INFACE_GUEST_GW4} | sed 's/\.1$/\.0/')/24"
	num_lines=$(/opt/sbin/iptables -t nat -L POSTROUTING --line-numbers | grep -c "${filter}")
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(/opt/sbin/iptables -t nat -L POSTROUTING --line-numbers \
					| grep "${filter}" \
					| cut -d" " -f1 \
					| head -1 \
					)
			/opt/sbin/iptables -t nat -D PREROUTING "${nline}" 2>"${res_file}"
		done
		log_when_error "${?}" "${app}::Маркировка гостевого POSTROUTING трафика ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}]"
	else
		logger_dev "${app}::Правила POSTROUTING iptable для гостевой сети ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}] отсутствуют."
	fi
}
# ------------------------------------------------------------------------------------------

ip4_del_guest_to_vpn_network(){
	ip4_flush_guest_preroute_rules
	ip4_flush_guest_postroute_rules
}

ip4_init_all(){
	ip4_flush_all_tables
	ip4_firewall_flush_all_rules
	ip4set_create_table
	/opt/apps/kvas/bin/main/ipset &
}
# ------------------------------------------------------------------------------------------
#
# Функции для поддержки протокола ip6
#
# ------------------------------------------------------------------------------------------
ip6() (/opt/sbin/ip -6 "$@")
ip6tables() (if ! /opt/sbin/ip6tables -C "$@" &>/dev/null; then ip6tables -A "$@"; fi)
ip6save() (/opt/sbin/ip6tables-save)

ip6set_create_table(){
	ipset create "${table_name}6" hash:net family inet6 -exist 2>"${res_file}"
	log_when_error "${?}" "${app}::Создание таблица с именем ${table_name} для ipset IPv6"
}
