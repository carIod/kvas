#!/bin/sh
#------------------------------------------------------------------------------
#	ПАКЕТ КВАС
#------------------------------------------------------------------------------
#
#	Данный файл служит библиотекой переменных среды и функций,
#	которые используются в событийном пакете ndm
#	https://github.com/ndmsystems/packages/wiki/Opkg-Component
#
# ------------------------------------------------------------------------------
#	Разработчик: mail@zeleza.ru
#	Дата создания: 13/09/2022
#	Лицензия: GPL 2.0
# ------------------------------------------------------------------------------------------

# имя таблицы для ipset
table_name=unblock

TABLE_ID=1001
PRIORITY=1778
MARK_NUM=0xd1000
DNS_PORT=53

INFACE_CLI=@CLI_INFACE_NAME
INFACE_ENT=@ENTWARE_INFACE_NAME

#как пример гостевая сеть br3, которой необходимо обеспечить доступ к VPN
INFACE_GUEST_ENT=

# Метка VPN цепочки для правил iptables
VPN_IPTABLES_CHAIN=VPNREDIR
# Метка SHADOWSOCKS цепочки для правил iptables
SSR_IPTABLES_CHAIN=SHADOWSOCKS
SSR_IPTABLES_CHAIN_MARK=SHADOWSOCKS_UDP_MARK

IPv4='IPv4::'
IPv6='IPv6::'

# ------------------------------------------------------------------------------------------
# Подключаем функции логирования
. /opt/apps/kvas/bin/libs/.main
# ------------------------------------------------------------------------------------------

ip4() (/opt/sbin/ip -4 "$@")
ip4tables() (/opt/sbin/iptables -C "$@" &>/dev/null || /opt/sbin/iptables -A "$@")
iptab() (/opt/sbin/iptables "$@")
ip4save() (/opt/sbin/iptables-save)
get_gw4()(ip4 addr show "${1}" | grep -Po "(?<=inet ).*(?=/)")

INFACE_GW4=$(get_gw4 "${INFACE_ENT}")


# ------------------------------------------------------------------------------------------
# в случае если задан гостевой интерфейс, получаем значение интерфейса и сетку IP
# ------------------------------------------------------------------------------------------
[ -n "${INFACE_GUEST_ENT}" ] && {
	INFACE_GUEST_GW4=$(get_gw4 "${INFACE_GUEST_ENT}")
	GUEST_NET="$(echo "${INFACE_GUEST_GW4}" | cut -d'.' -f1-3).0/24"
}

# ------------------------------------------------------------------------------------------
# проверка на доступность программного и аппаратного ускорения
# ------------------------------------------------------------------------------------------
fastnet_support()(curl -s localhost:79/rci/show/version | grep -q ppe)
fast_hw_enabled()(! curl -s localhost:79/rci/show/rc/ppe | grep hardware -C1 | grep -q false)
fast_sw_enabled()(! curl -s localhost:79/rci/show/rc/ppe | grep software -C1 | grep -q false)
fastnet_enabled()(fast_hw_enabled || fast_sw_enabled)

# ------------------------------------------------------------------------------------------
# Производим очистку кэша маршрутизации
# ------------------------------------------------------------------------------------------
ip4_flush_cache(){
	log_warning "Проводим очистку кеша маршрутизации."
	ip4 route flush cache 1> /dev/null 2> "${ERROR_LOG_FILE}"
	when_error "${?}" " ${IPv4} Возникла ошибка при очистки кеша маршрутизации."
}


# ------------------------------------------------------------------------------------------
# Подключаем правила для корректной работы DNS трафика через 53 порт
# ------------------------------------------------------------------------------------------
ip4_firewall_dns_rules_set(){
	inface="${1}"
	local_ip=${2}
	protocol=${3}
	#	Если не заданы аргументы, то ничего не выполняем
	if [ -n "${inface}" ] && [ -n "${local_ip}" ] && [ -n "${protocol}" ] ; then

		[ "${inface}" = '@ENTWARE_INFACE_NAME' ] && {
			# если правила для tcp есть, то пропускаем их добавление
			if ! ip4save | grep -q "${protocol} \-\-dport ${DNS_PORT} \-j DNAT"; then
				log_warning "Подключаем правила для корректной работы DNS трафика через 53 порт:"
				log_warning "Интерфейс: ${inface}, IP: ${local_ip}, протокол: ${protocol}."

				ip4tables PREROUTING -w -t nat -i "${inface}" -p "${protocol}" --dport ${DNS_PORT} -j DNAT --to "${local_ip}" 1> /dev/null 2> "${ERROR_LOG_FILE}"
				when_error "${?}" " ${IPv4} Ошибка при установке правил для DNS."
			fi
		}
	else
		log_error "При вызове ip4_firewall_dns_rules_set не были заданы обязательные аргументы."
	fi
}


# ------------------------------------------------------------------------------------------
# Подключаем Firewall правила, которые исключают из работы локальные запросы
# ------------------------------------------------------------------------------------------
ip4_firewall_exclude_locals(){
	chain_name=${1}; table=${2};
#	Если не заданы аргументы, то ничего не выполняем
	if [ -n "${chain_name}" ] && [ -n "${table}" ]; then
		log_warning "Подключаем правила для таблицы ${table} и цепочки ${chain_name}, которые исключают из работы локальные запросы."
	#	> "${ERROR_LOG_FILE}"
	#	{
		iptab -S ${VPN_IPTABLES_CHAIN} -t "${table}" 2>/dev/null | grep -q '\-N' || iptab -N ${VPN_IPTABLES_CHAIN} -t "${table}"

		while read -r _net || [ -n "${_net}" ]; do
			[ -z "${_net}" ] && continue
			#  пропускаем строки с комментариями
			[ ${_net:0:1} = '#' ] && continue
			# удаляем из строк комментарии - все что встречается после символа # и сам символ
			_net=$(echo "${_net}" | sed 's/#.*$//g' | tr -s ' ' )
			ip4tables "${chain_name}" -t "${table}" -d "${_net}" -j RETURN &>/dev/null

		done < "${EXCLUDED_NET_FILE}"
	else
		log_error "При вызове ip4_firewall_exclude_locals не были заданы обязательные аргументы."
	fi
}


# ------------------------------------------------------------------------------------------
# Маркируем VPN подключения, когда программное и аппаратное ускорение ПОДКЛЮЧЕНО
# ------------------------------------------------------------------------------------------
ip4_firewall_vpn_mark(){
	ip4save | grep "${VPN_IPTABLES_CHAIN}" | grep -qv '\[0:0\]' || {
		# Маркируем трафик для домашней(основной) сети и прохождение пакетов через VPN подключение
		{
			table=mangle
			log_warning "Маркируем VPN подключения, когда программное и аппаратное ускорение ПОДКЛЮЧЕНО"

			iptab -S ${VPN_IPTABLES_CHAIN} -t "${table}" 2>/dev/null | grep -q '\-N' || iptab -N ${VPN_IPTABLES_CHAIN} -t "${table}"
			ip4tables ${VPN_IPTABLES_CHAIN} -t "${table}" -m set ! --match-set "${table_name}" dst -j RETURN

			# Игнорируем локальные сети и любые другие адреса, которые вы хотели бы обойти прокси
			ip4_firewall_exclude_locals ${VPN_IPTABLES_CHAIN} "${table}"

			ip4tables ${VPN_IPTABLES_CHAIN} -t "${table}" -j CONNMARK --restore-mark
			ip4tables ${VPN_IPTABLES_CHAIN} -t "${table}" -m mark --mark ${MARK_NUM} -j RETURN
			ip4tables ${VPN_IPTABLES_CHAIN} -t "${table}" -p tcp --syn -j MARK --set-mark ${MARK_NUM}
			ip4tables ${VPN_IPTABLES_CHAIN} -t "${table}" -p udp -m conntrack --ctstate NEW -j MARK --set-mark ${MARK_NUM}
			ip4tables ${VPN_IPTABLES_CHAIN} -t "${table}" -j CONNMARK --save-mark

			ip4tables PREROUTING -t "${table}" -p tcp -m set --match-set "${table_name}" dst -j ${VPN_IPTABLES_CHAIN}
			ip4tables PREROUTING -t "${table}" -p udp -m set --match-set "${table_name}" dst -j ${VPN_IPTABLES_CHAIN}
			ip4tables OUTPUT     -t "${table}" -p tcp -m set --match-set "${table_name}" dst -j ${VPN_IPTABLES_CHAIN}
			ip4tables OUTPUT     -t "${table}" -p udp -m set --match-set "${table_name}" dst -j ${VPN_IPTABLES_CHAIN}

		} 2> "${ERROR_LOG_FILE}"
		when_error "${?}" " ${IPv4} Во время маркировки трафика для VPN соединений возникли ошибки."
	}
}


# ------------------------------------------------------------------------------------------
#
# 	Маркировка VPN подключений когда программное и аппаратное ускорение ОТКЛЮЧЕНО
#
# ------------------------------------------------------------------------------------------
ip4_firewall_mark_rules_tcp_udp_on(){
	if ! ip4save | grep "\j MARK" | grep -q "${table_name}" ; then
		{
			log_warning "Маркировка VPN подключений когда программное и аппаратное ускорение ОТКЛЮЧЕНО."
			# Исключаем маркировку трафика для гостевой (в том числе) сети
			ip4tables PREROUTING -t mangle -i "${INFACE_ENT}" -p tcp -m set --match-set ${table_name} dst -j MARK --set-mark ${MARK_NUM}
			ip4tables PREROUTING -t mangle -i "${INFACE_ENT}" -p udp -m set --match-set ${table_name} dst -j MARK --set-mark ${MARK_NUM}

		}  2> "${ERROR_LOG_FILE}"
		when_error "${?}" " ${IPv4} Возникла ошибка при маркировке трафика гостевой сети для tcp или udp."
	fi
}


# ------------------------------------------------------------------------------------------
#
# 	Правила маркировки гостевого трафика
#
# ------------------------------------------------------------------------------------------
ip4_add_guest_to_vpn_network(){
	ip4save | grep "\-j MASQUERADE" | grep -q "${INFACE_GUEST_ENT}" && {
		# Маркируем трафик гостевой сети
		{
			log_warning "Подключаем правила маркировки гостевого трафика."
			ip4tables PREROUTING -t nat -p udp -d "${INFACE_GUEST_GW4}" --dport ${DNS_PORT} -j DNAT --to "${INFACE_GW4}:53"
			ip4tables POSTROUTING -t nat -s "${GUEST_NET}" -o "${INFACE_GUEST_ENT}" -j MASQUERADE
		} 2> "${ERROR_LOG_FILE}"
		when_error "${?}" " ${IPv4} Возникла ошибка при маркировке гостевого трафика ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}]"
	}
}


# ------------------------------------------------------------------------------------------
#
# 	Установка правил для VPN подключений в зависимости от флагов
#
# ------------------------------------------------------------------------------------------
ip4_mark_vpn_network(){

	if fastnet_enabled ; then
		#log_warning "${app}::Проверка пройдена -> программное и аппаратное ускорение ПОДКЛЮЧЕНО."
		# Без отключения ускорителей fastnat и hwnat
		ip4_firewall_vpn_mark
	else
		#log_warning "${app}::Проверка пройдена -> программное и аппаратное ускорение ОТКЛЮЧЕНО!"
		# С отключением fastnat и ускорителей hwnat
		ip4_firewall_mark_rules_tcp_udp_on
	fi
#	в случае наличия гостевой сети
	if [ -n "${INFACE_GUEST_ENT}" ]; then
		ip4_add_guest_to_vpn_network
	fi
}

# ------------------------------------------------------------------------------------------
#
# 	Установка правил для SHADOWSOCKS подключений
#
# ------------------------------------------------------------------------------------------
ip4_firewall_set_ssr_rules(){
	inface="${1:-lo}"
	proxy_port="${2}"

	# Источник:
	# https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-redir.asciidoc?ysclid=l949tgrsfn795375643
	# Создаем новую цепочку SHADOWSOCKS

	#	Если не заданы аргументы, то ничего не выполняем
	if [ -n "${inface}" ] && [ -n "${proxy_port}" ] ; then

		[ "${inface}" = '@INFACE' ] || {

			ip4save | grep "${SSR_IPTABLES_CHAIN}" | grep -qv '\[0:0\]' || \
			ip4save | grep "${SSR_IPTABLES_CHAIN_MARK}" | grep -qv '\[0:0\]' ||  {

				log_warning "Подключаем правила для SHADOWSOCKS интерфейса ${inface} порт ${proxy_port}."


				iptab -S ${SSR_IPTABLES_CHAIN} -t nat 2>/dev/null | grep -q '\-N' || iptab -N ${SSR_IPTABLES_CHAIN} -t nat
				iptab -S ${SSR_IPTABLES_CHAIN_MARK} -t mangle 2>/dev/null | grep -q '\-N' || iptab -N ${SSR_IPTABLES_CHAIN_MARK} -t mangle

				# Игнорируем локальные сети и любые другие адреса, которые вы хотели бы обойти прокси
				ip4_firewall_exclude_locals ${SSR_IPTABLES_CHAIN} nat

				ssr_ip=$(cat < /opt/etc/shadowsocks.json | grep 'server":' | tr -d '" ,' | cut -d':' -f2 )
				# Исключаем любые обращения к собственному адресу SHADOWSOCKS
				ip4tables ${SSR_IPTABLES_CHAIN} -t nat -d "${ssr_ip}" -j RETURN

				# Anything else should be redirected to shadowsocks's local port
				ip4tables ${SSR_IPTABLES_CHAIN} -t nat  ! -p icmp -j REDIRECT --to-ports "${proxy_port}"
		#		Apply the rules
				ip4tables PREROUTING -t nat ! -p icmp -j ${SSR_IPTABLES_CHAIN}

				# Создаем таблицы для IP адресов
				ip4 route show table ${TABLE_ID} | grep -q "${inface}" || \
					ip4 route add local default dev "${inface}" table ${TABLE_ID}
				ip4 rule list | grep -q "fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID}" || \
					ip4 rule add fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID}

		#		Правила для маркировки UPD трафика
				ip4tables ${SSR_IPTABLES_CHAIN_MARK} -t mangle -p udp -m set --match-set ${table_name} dst -j RETURN
				ip4tables ${SSR_IPTABLES_CHAIN_MARK} -t mangle -p udp -j MARK --set-mark ${MARK_NUM}

				# Apply the rules
				ip4tables OUTPUT -t mangle -p udp -j ${SSR_IPTABLES_CHAIN_MARK}

			} 2> "${ERROR_LOG_FILE}"
			when_error "${?}" " ${IPv4} Возникла ошибка при установке правил iptable для Shadowsocks подключения"
		}

	else
		log_error "При вызове ip4_firewall_set_ssr_rules не были заданы обязательные аргументы."
	fi
}

# ------------------------------------------------------------------------------------------
#
# 	Установка правил для любых типов подключений (SHADOWSOCKS или VPN)
#
# ------------------------------------------------------------------------------------------
ip4_firewall_set_all_rules(){

#   Если активно VPN соединение
	if [ -f "/opt/etc/ndm/netfilter.d/100-vpn-mark" ]; then
		ip4_mark_vpn_network
	else
#		Если активно SHADOWSOCKS соединение
		local_ip=$(get_router_ip)
		inface=$(get_inface_by_ip "${local_ip}")
		proxy_port=$(get_config_value SSR_DNS_PORT)
		ip4_firewall_set_ssr_rules "${inface}" "${proxy_port}"

	fi

}




# ------------------------------------------------------------------------------------------
# 	Производим удаление правил и удаляем саму цепочку
# ------------------------------------------------------------------------------------------
ip4tbl_flush_rm_chain(){
	table="${1}"; chain="${2}"
	#	Если не заданы аргументы, то ничего не выполняем
	if [ -n "${table}" ] && [ -n "${chain}" ] ; then
		ip4save | grep -q "${chain}" && {
			log_warning "Производим удаление правил в таблице ${table} и цепочке ${route} и удаляем цепочку."
			iptab -F "${chain}" -t "${table}"
			iptab -X "${chain}" -t "${table}"
		}
	else
		log_error "При вызове ip4tbl_flush_rm_chain не были заданы обязательные аргументы."
	fi
}


# ------------------------------------------------------------------------------------------
# Производим удаление правил в указанной таблице в одной из стандартных цепочек
# ------------------------------------------------------------------------------------------
ip4tbl_flush_rm_pre_out(){

	table="${1}"; chain="${2}"; route="${3}"; icmp_arg=${4:-'no'}
	if [ -n "${table}" ] && [ -n "${chain}" ] && [ -n "${route}" ] ; then
		log_warning "Производим удаление стандартных правил в таблице ${table}, цепочке ${route} для ${chain}"

		for prot in tcp udp icmp; do
			ip4save | grep "${route}" | grep "${chain}" | grep -q "${prot}" && {
				if [ "${icmp_arg}" = 'icmp' ] && [ "${prot}" = icmp ]; then
					iptab -t "${table}" -D "${route}" ! -p "${prot}" -j "${chain}"
				else
					iptab -t "${table}" -D "${route}" -p "${prot}" -j "${chain}"
				fi
			}
		done
	else
		log_error "При вызове ip4tbl_flush_rm_pre_out не были заданы обязательные аргументы."
	fi
}

# ------------------------------------------------------------------------------------------
# Производим удаление правил в указанной таблице в одной из стандартных цепочек
# c правилами содержащими '-m set --match-set ${table_name} dst'
# ------------------------------------------------------------------------------------------
ip4tbl_flush_rm_match_set(){

	table="${1}"; chain="${2}"; route="${3}";
	if [ -n "${table}" ] && [ -n "${chain}" ] && [ -n "${route}" ] ; then
		log_warning "Производим удаление правил match-set в таблице ${table}, цепочке ${route} для ${chain}"

		for prot in tcp udp; do
			ip4save | grep "${route}" | grep "${chain}" | grep -q "${prot}" && {
				iptab -t "${table}" -D "${route}" -p "${prot}" -m set --match-set ${table_name} dst -j "${chain}"
			}
		done
	else
		log_error "При вызове ip4tbl_flush_rm_match_set не были заданы обязательные аргументы."
	fi
}

# ------------------------------------------------------------------------------------------
#
# Удаляем VPN правила для случая когда программное и аппаратное ускорение ПОДКЛЮЧЕНО
#
# ------------------------------------------------------------------------------------------
ip4_firewall_fastnet_vpn_prune(){
	table=mangle; chain="${VPN_IPTABLES_CHAIN}"
	{
		ip4tbl_flush_rm_match_set "${table}" "${chain}" PREROUTING
		ip4tbl_flush_rm_match_set "${table}" "${chain}" OUTPUT
		ip4tbl_flush_rm_chain "${table}" "${chain}"

	} 2> "${ERROR_LOG_FILE}"
	when_error "${?}" "${IPv4} Возникла ошибка при обнулении VPN правил iptables для цепочки ${table}."
}


# ------------------------------------------------------------------------------------------
#
# Удаляем VPN правила для случая когда программное и аппаратное ускорение ОТКЛЮЧЕНО
#
# ------------------------------------------------------------------------------------------
ip4_firewall_nofastnet_vpn_prune(){
	table=mangle; chain="${VPN_IPTABLES_CHAIN}"
	{
		ip4tbl_flush_rm_pre_out "${table}" "${chain}" PREROUTING
		ip4tbl_flush_rm_chain "${table}" "${chain}"

	} 2> "${ERROR_LOG_FILE}"
	when_error "${?}" "${IPv4} Возникла ошибка при обнулении VPN правил iptables для цепочки ${table}."
}


# ------------------------------------------------------------------------------------------
#
# Удаляем все правила iptables для SHADOWSOCKS подключений,
# которые были добавлены при работе пакета в старой редакции
#
# ------------------------------------------------------------------------------------------
ip4_firewall_ssr_prune(){

	ip4tbl_flush_rm_pre_out nat "${SSR_IPTABLES_CHAIN}" PREROUTING icmp
	ip4tbl_flush_rm_chain nat "${SSR_IPTABLES_CHAIN}"

	ip4tbl_flush_rm_pre_out mangle "${SSR_IPTABLES_CHAIN_MARK}" OUTPUT icmp
	ip4tbl_flush_rm_chain mangle "${SSR_IPTABLES_CHAIN_MARK}"
}


# ------------------------------------------------------------------------------------------
#
# Удаляем все правила iptables для SHADOWSOCKS подключений,
# которые были добавлены при работе пакета в старой редакции
#
# ------------------------------------------------------------------------------------------
ip4_firewall_flush_vpn_guest_rules(){
	iptab -D PREROUTING -t nat -p udp -d "${INFACE_GUEST_GW4}" --dport ${DNS_PORT} -j DNAT --to "${INFACE_GW4}:53"
	iptab -D POSTROUTING -t nat -s "${GUEST_NET}" -o "${INFACE_GUEST_ENT}" -j MASQUERADE
}


# ------------------------------------------------------------------------------------------
#
# 	Удаляем все правила iptables которые были добавлены при работе пакета
#
# ------------------------------------------------------------------------------------------
ip4_firewall_flush_vpn_rules(){
	if fastnet_enabled ; then
#		Если программное и аппаратное ускорение ПОДКЛЮЧЕНО
		ip4_firewall_fastnet_vpn_prune
	else
#		Если программное и аппаратное ускорение ОТКЛЮЧЕНО
		ip4_firewall_nofastnet_vpn_prune
	fi
	if [ -n "${INFACE_GUEST_ENT}" ]; then ip4_firewall_flush_vpn_guest_rules; fi
}
# ------------------------------------------------------------------------------------------
#
# 	Удаляем все правила iptables которые были добавлены при работе пакета
#
# ------------------------------------------------------------------------------------------
ip4_firewall_flush_all_rules(){
	> "${ERROR_LOG_FILE}" # Обнуление файла журналирования

#   Если активно VPN соединение
	if [ -f "/opt/etc/ndm/netfilter.d/100-vpn-mark" ]; then
		ip4_firewall_flush_vpn_rules
	else
#		Если активно SHADOWSOCKS соединение
		ip4_firewall_ssr_prune
	fi

}

# ------------------------------------------------------------------------------------------
#
# 	Удаляем все таблицы которые были созданы при работе пакета
#
# ------------------------------------------------------------------------------------------
ip4_flush_all_tables(){

	log_warning "IPset::Производим очистку записей таблицы ${table_name}."
	ipset flush "${table_name}" 2> "${ERROR_LOG_FILE}"
	when_error "${?}" " ${IPv4} Возникла ошибка при очистке записей ipset таблицы ${table_name}"

	log_warning "IPv4::Производим очистку записей таблицы маршрутизации ID#${TABLE_ID}."
	ip4 route flush table "${TABLE_ID}" 2> "${ERROR_LOG_FILE}"
	when_error "${?}" " ${IPv4} Возникла ошибка при очистке таблицы маршрутизации ID#${TABLE_ID}"

	ip4_flush_cache
}


# ------------------------------------------------------------------------------------------
#
# 	Создаем ip4 таблицу ${TABLE_ID} и копируем в нее данные из таблицы main
#
# ------------------------------------------------------------------------------------------
ip4_add_route_table(){

	if [ -z "$(ip4 route show table ${TABLE_ID})" ]; then
		log_warning "IPv4::Создаем таблицу маршрутизации ID#${TABLE_ID} для '${INFACE_CLI}'."
		ip4 route add table ${TABLE_ID} default via "${INFACE_GW4}" dev ${INFACE_ENT} 2> "${ERROR_LOG_FILE}"
		when_error "${?}" " ${IPv4} Возникла ошибка при создании таблицы маршрутизации ID#${TABLE_ID} для '${INFACE_CLI}' интерфейса"

		log_warning "IPv4::Копируем записи таблицы main в таблицу ID#${TABLE_ID}."
		ip4 route show table main | grep -Ev ^default | \
		while read -r ROUTE; do
#			Выделяем из строки ROUTE только первых три разряда сети, как пример: 10.0.124
			_net=$(echo "${ROUTE}" | sed 's/^\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\).*/\1/')
#			Если сеть доступна в роутере на текущий момент, то добавляем ее
			ip a | grep -q "${_net}" && ip4 route add table ${TABLE_ID} ${ROUTE}
		done
#		Проверяем на число записей в таблице ${TABLE_ID} - их должно быть больше чем одна запись
		test "$(ip4 route show table ${TABLE_ID} | grep -c dev)" -gt 1
		when_error "${?}" "${IPv4} В таблицу с ID#${TABLE_ID} НЕ БЫЛИ скопированы записи из таблицы main!"
	fi
}

# ------------------------------------------------------------------------------------------
#
# 	Устанавливаем приоритет таблицы ID#${TABLE_ID} в значение ${PRIORITY}
#
# ------------------------------------------------------------------------------------------
ip4_rule_set_priority(){

	if ! ip4 rule show | grep -q "fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID}"  ; then
		log_warning "IPv4::Устанавливаем приоритет таблицы ID#${TABLE_ID} в значение ${PRIORITY}"
		ip4 rule add fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID} priority ${PRIORITY} 2> "${ERROR_LOG_FILE}"
		when_error "${?}" " ${IPv4} Возникла ошибка при установке приоритета таблицы с ID#${TABLE_ID} в значение ${PRIORITY}"
	fi

	ip4_flush_cache
}


# ------------------------------------------------------------------------------------------
#
# 	Обнуляем приоритет таблицы ID#${TABLE_ID}
#
# ------------------------------------------------------------------------------------------
ip4_rule_del_priority(){

	if ip4 rule show | grep -q "fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID}"  ; then
		log_warning "IPv4::Обнуляем приоритет таблицы ID#${TABLE_ID}"
		ip4 rule del fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID} priority ${PRIORITY} 2> "${ERROR_LOG_FILE}"
		when_error "${?}" " ${IPv4} Обнуление приоритета таблицы с ID#${TABLE_ID}"
	fi

	ip4_flush_cache
}


# ------------------------------------------------------------------------------------------
#
# 	IPset::Cоздаем таблицу с именем '${table_name}'
#
# ------------------------------------------------------------------------------------------
ip4set_create_table(){
	if ipset list ${table_name} 2>&1 | grep -q 'name does not exist' ; then
		log_warning "IPset::Cоздаем таблицу с именем '${table_name}'."
		ipset create ${table_name} hash:net family inet -exist 2> "${ERROR_LOG_FILE}"
		when_error "${?}" "${IPv4} Возникла ошибка при создании таблицы с именем '${table_name}' для ipset"
	fi
}


# ------------------------------------------------------------------------------------------
#
# 	Пересоздаем все ранее созданные таблицы для утилит ipset и ip
#
# ------------------------------------------------------------------------------------------
recreate_ip4tables(){
	ready "${prefix}Удаляем все ранее созданные таблицы для утилит ipset и ip"
	ip4_flush_all_tables &>/dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	ready "${prefix}Создаем все необходимые таблицы для утилит ipset и ip"
	ip4set_create_table &>/dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	ready "${prefix}Создаем таблицу маршрутизации ID#${TABLE_ID} для '${INFACE_CLI}'."
#	Создаем таблицу IP адресов для  VPN подключения отличного от shadowsocks
	ip4_add_route_table #&> /dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
}


# ------------------------------------------------------------------------------------------
#
# 	Пересоздаем все необходимые правила для корректной работы VPN соединения
#
# ------------------------------------------------------------------------------------------
recreate_vpn_rules(){
	ready "${prefix}Очищаем все ранее созданные iptables правила для VPN."
	ip4_firewall_flush_vpn_rules # &>/dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	ready "${prefix}Обнуляем приоритет таблицы ID#${TABLE_ID}"
	ip4_rule_del_priority &>/dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	ready "${prefix}Устанавливаем приоритет таблицы ID#${TABLE_ID} в значение ${PRIORITY}"
#	Устанавливаем приоритет таблицы
	ip4_rule_set_priority &> /dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	ready "${prefix}Создаем iptables правила для VPN соединения."
#	Создаем правила iptables
	ip4_mark_vpn_network &> /dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
}

# ------------------------------------------------------------------------------------------
#
# 	Пересоздаем все необходимые правила для корректной работы SHADOWSOCKS соединения
#
# ------------------------------------------------------------------------------------------
recreate_ssr_rules(){
	ready "${prefix}Очищаем все ранее созданные iptables правила для SHADOWSOCKS"
#		Если активно SHADOWSOCKS соединение
	ip4_firewall_ssr_prune &>/dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	ready "${prefix}Создаем iptables правила для SHADOWSOCKS соединения."
	local_ip=$(get_router_ip)
	inface=$(get_inface_by_ip "${local_ip}")
	proxy_port=$(get_config_value SSR_DNS_PORT)
	ip4_firewall_set_ssr_rules "${inface}" "${proxy_port}" &> /dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
}

# ------------------------------------------------------------------------------------------
#
# 	Пересоздаем таблицу ipset для AdGuard Home и перезапускаем сервис
#
# ------------------------------------------------------------------------------------------
refresh_adguard_ipset_table(){
	ready "${prefix}Заполняем AdGuard таблицу данными из списка разблокировки."
	/opt/apps/kvas/bin/main/adguard &>/dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	ready "${prefix}Перезапускаем сервис AdGuard Home"
	/opt/etc/init.d/S99adguardhome restart &>/dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
}

# ------------------------------------------------------------------------------------------
#
# 	Пересоздаем таблицу ipset для dnsmasq и перезапускаем сервис
# 	В том числе и обрабатываем dns_crypt в случае, если он запущен
#
# ------------------------------------------------------------------------------------------
refresh_dnsmasq_ipset_table(){

		ready "${prefix}Заполняем dnsmasq таблицу данными из списка разблокировки."
		/opt/apps/kvas/bin/main/dnsmasq &>/dev/null
		[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

		ready "${prefix}Перезапускаем сервис dnsmasq"
		/opt/etc/init.d/S56dnsmasq restart &>/dev/null
		[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

		if get_dns_crypt_status | grep -q on ; then
			ready "${prefix}Перезапускаем сервис dns_crypt"
			dns_crypt_install '' &>/dev/null
			[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
		fi
}


# ------------------------------------------------------------------------------------------
#
# 	Производим иницилизацию пакета КВАС
#
# ------------------------------------------------------------------------------------------
cmd_kvas_init(){

	prefix=''
	mess="${prefix}Производим иницилизацию пакета КВАС"
	warning "${mess}"; log_error "${mess}"
	print_line

	recreate_ip4tables


	if [ -f "/opt/etc/ndm/netfilter.d/100-vpn-mark" ]; then
		recreate_vpn_rules
	else
		recreate_ssr_rules
	fi

	ready "${prefix}Заполняем ipset таблицу данными из списка разблокировки."
	/opt/apps/kvas/bin/main/ipset &> /dev/null &
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	if cmd_adguardhome_status | grep -q "ВКЛЮЧЕН" ; then
		refresh_adguard_ipset_table
	else
		refresh_dnsmasq_ipset_table
	fi
	if cmd_ads_status | grep -q 'ВКЛЮЧЕНА' ; then
		ready "${prefix}Обновляем данные списка блокировки рекламы."
		/opt/apps/kvas/bin/main/adblock &>/dev/null
		[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"
	fi

	ready "${prefix}Синхронизируем дату роутера с сервером времени."
	date_update &>/dev/null
	[ $? = 0 ] && when_ok "ГОТОВО" || when_bad "ОШИБКА"

	log_error "${prefix}Иницилизация пакета КВАС ЗАВЕРШЕНА!"

}

# ------------------------------------------------------------------------------------------
#
# Функции для поддержки протокола ip6
#
# ------------------------------------------------------------------------------------------
ip6() (/opt/sbin/ip -6 "$@")
ip6tables() (if ! /opt/sbin/ip6tables -C "$@" &>/dev/null; then ip6tables -A "$@"; fi)
ip6save() (/opt/sbin/ip6tables-save)

ip6set_create_table(){
	ipset create "${table_name}6" hash:net family inet6 -exist 2> "${ERROR_LOG_FILE}"
	when_error "${?}" "${IPv6}Возникла ошибка при создании таблицы с именем '${table_name}' для ipset"
}
