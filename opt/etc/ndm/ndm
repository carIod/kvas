#!/bin/sh
#------------------------------------------------------------------------------
#	ПАКЕТ КВАС
#------------------------------------------------------------------------------
#
#	Данный файл служит библиотекой переменных среды и функций,
#	которые используются в событийном пакете ndm
#	https://github.com/ndmsystems/packages/wiki/Opkg-Component
#
# ------------------------------------------------------------------------------
#	Разработчик: mail@zeleza.ru
#	Дата создания: 13/09/2022
#	Лицензия: GPL 2.0
# ------------------------------------------------------------------------------------------
LOG_ENABLE=YES
app="КВАС"
# имя таблицы для ipset
table_name=unblock

TABLE_ID=1001
PRIORITY=1778
MARK_NUM=0xd1000
DNS_PORT=53

INFACE_CLI=@CLI_INFACE_NAME
INFACE_ENT=@ENTWARE_INFACE_NAME

#как пример гостевая сеть br3, которой необходимо обеспечить доступ к VPN
INFACE_GUEST_ENT=

# Файл временного хранения результатов исполнения команды
res_file=/opt/tmp/kvas.result
# ------------------------------------------------------------------------------------------

# Функции логирования результата
logger_dev()( [ "${LOG_ENABLE}" ] && logger "${1}" )
log_result(){
#	Если логирование подключено
	[ "${LOG_ENABLE}" = "YES" ] && {
		operation_result="${1}"
		log_message="${2}"
		if [ "${operation_result}" = 0 ]; then
			logger "${log_message} УСПЕШНО."
		else
			logger "${log_message} C ОШИБКОЙ!"
			logger "$(cat "${res_file}")"
		fi
		rm -f "$(cat "${res_file}")"
	}
}
# ------------------------------------------------------------------------------------------

ip4() (/opt/sbin/ip -4 "$@")
ip4tables() (if ! /opt/sbin/iptables -C "$@" &>/dev/null; then /opt/sbin/iptables -A "$@"; fi)
ip4save() (/opt/sbin/iptables-save)
get_gw4()(ip4 addr show "${1}" | grep -Po "(?<=inet ).*(?=/)")

INFACE_GW4=$(get_gw4 "${INFACE_ENT}")

# в случае если задан гостевой интерфейс
[ -n "${INFACE_GUEST_ENT}" ] && {
	INFACE_GUEST_GW4=$(get_gw4 "${INFACE_GUEST_ENT}")
	GUEST_NET="$(echo "${INFACE_GUEST_GW4}" | cut -d'.' -f1-3).0/24"
}

# ------------------------------------------------------------------------------------------
# проверка на доступность программного и аппаратного ускорения
# ------------------------------------------------------------------------------------------
fastnet_support()(curl -s localhost:79/rci/show/version | grep -q ppe)
fast_hw_enabled()(! curl -s localhost:79/rci/show/rc/ppe | grep hardware -C1 | grep -q false)
fast_sw_enabled()(! curl -s localhost:79/rci/show/rc/ppe | grep software -C1 | grep -q false)
fastnet_enabled()(fast_hw_enabled || fast_sw_enabled)
# ------------------------------------------------------------------------------------------

ip4_flush_cache(){
	ip4 route flush cache > "${res_file}"
	log_result "${?}" "${app}::Очистка кеша маршрутизации произведена"
}
# ------------------------------------------------------------------------------------------

ip4_firewall_dns_rules_set(){
	inface="${1}"
	local_ip=${2}
	protocol=${3}
	# если правила для tcp есть, то пропускаем их добавление
	if ! ip4save | grep -q "${protocol} \-\-dport ${DNS_PORT} \-j DNAT"; then
		ip4tables PREROUTING -w -t nat -i ${inface} -p ${protocol} --dport ${DNS_PORT} -j DNAT --to ${local_ip}
	fi
}
# ------------------------------------------------------------------------------------------
# Маркировка VPN подключений когда программное и аппаратное ускорение ПОДКЛЮЧЕНО
# ------------------------------------------------------------------------------------------
ip4_firewall_mark_vpn(){
	if ! ip4save | grep -q "VPNREDIR" ; then
		# Маркируем трафик для домашней(основной) сети и прохождение пакетов через VPN подключение
		{
			iptables -N VPNREDIR -t mangle
			ip4tables VPNREDIR -t mangle -m set ! --match-set "${table_name}" dst -j RETURN
			ip4tables VPNREDIR -t mangle -d 0.0.0.0/8 -j RETURN
			ip4tables VPNREDIR -t mangle -d 127.0.0.0/8 -j RETURN
			ip4tables VPNREDIR -t mangle -d 10.0.0.0/8 -j RETURN
			ip4tables VPNREDIR -t mangle -d 169.254.0.0/16 -j RETURN
			ip4tables VPNREDIR -t mangle -d 172.16.0.0/12 -j RETURN
			ip4tables VPNREDIR -t mangle -d 192.168.0.0/16 -j RETURN
			ip4tables VPNREDIR -t mangle -j CONNMARK --restore-mark
			ip4tables VPNREDIR -t mangle -m mark --mark ${MARK_NUM} -j RETURN
			ip4tables VPNREDIR -t mangle -p tcp --syn -j MARK --set-mark ${MARK_NUM}
			ip4tables VPNREDIR -t mangle -p udp -m conntrack --ctstate NEW -j MARK --set-mark ${MARK_NUM}
			ip4tables VPNREDIR -t mangle -j CONNMARK --save-mark

			ip4tables PREROUTING -t mangle -p tcp -m set --match-set "${table_name}" dst -j VPNREDIR
			ip4tables PREROUTING -t mangle -p udp -m set --match-set "${table_name}" dst -j VPNREDIR
			ip4tables OUTPUT     -t mangle -p tcp -m set --match-set "${table_name}" dst -j VPNREDIR
			ip4tables OUTPUT     -t mangle -p udp -m set --match-set "${table_name}" dst -j VPNREDIR

		} 2> "${res_file}"
#
#		ip4tables PREROUTING -t mangle -m conntrack --ctstate NEW -m set --match-set "${table_name}" dst -j CONNMARK --set-mark ${MARK_NUM} 2>"${res_file}"
#		ip4tables PREROUTING -t mangle -j CONNMARK --restore-mark >> "${res_file}"
		log_result "${?}" "${app}::Маркировка трафика для VPN соединений подключена"
	fi
}
# ------------------------------------------------------------------------------------------
# Маркировка VPN подключений когда программное и аппаратное ускорение ОТКЛЮЧЕНО
# ------------------------------------------------------------------------------------------
ip4_firewall_mark_rules_tcp_udp_on(){
	if ! ip4save | grep "\j MARK" | grep -q "${table_name}" ; then
		# Исключаем маркировку трафика для гостевой (в том числе) сети
		ip4tables PREROUTING -t mangle -i "${INFACE_GUEST_ENT}" -p tcp -m set --match-set ${table_name} dst -j MARK --set-mark ${MARK_NUM} 2>"${res_file}"
		ip4tables PREROUTING -t mangle -i "${INFACE_GUEST_ENT}" -p udp -m set --match-set ${table_name} dst -j MARK --set-mark ${MARK_NUM} 2>>"${res_file}"
		log_result "${?}" "${app}::Маркировка трафика гостевой сети для tcp и udp подключена"
	fi
}
# ------------------------------------------------------------------------------------------

ip4_firewall_set_ssr_rules(){
	inface="${1}"
	proxy_port="${2}"
	ip4tables PREROUTING -w -t nat -i ${inface} -p tcp -m set --match-set "${table_name}" dst -j REDIRECT --to-port ${proxy_port} 2>"${res_file}"
	log_result "${?}" "${app}::Установка установка правил iptable для Shadowsocks подключения произведена"
}
# ------------------------------------------------------------------------------------------

ip4_firewall_flush_vpn_rules(){
	num_lines=$(/opt/sbin/iptables -t mangle -L PREROUTING --line-numbers | grep CONNMARK | grep -cE "(${table_name}|restore-mark)")
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(/opt/sbin/iptables -t mangle -L PREROUTING --line-numbers \
					| grep CONNMARK \
					| grep -E "(${table_name}|restore-mark)" \
					| cut -d" " -f1 \
					| head -1 \
					)
			/opt/sbin/iptables -t mangle -D PREROUTING "${nline}" 2>"${res_file}"
		done
		log_result "${?}" "${app}::Очистка правил iptable для VPN подключения произведена"
	else
		logger_dev "${app}::Правила iptable для VPN подключения отсутствуют."
	fi
}
# ------------------------------------------------------------------------------------------

ip4_firewall_flush_ssr_rules(){

	num_lines=$(/opt/sbin/iptables -t nat -L PREROUTING --line-numbers | grep -c "${table_name}")
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(/opt/sbin/iptables -t nat -L PREROUTING --line-numbers \
					| grep "${table_name}" \
					| cut -d" " -f1 \
					| head -1\
					)
			/opt/sbin/iptables -t nat -D PREROUTING "${nline}" 2>"${res_file}"
		done
		log_result "${?}" "${app}::Очистка правил iptable для Shadowsocks подключения произведена"
	else
		logger_dev "${app}::Правила iptable для Shadowsocks подключения отсутствуют."
	fi
}
# ------------------------------------------------------------------------------------------

ip4_firewall_flush_all_rules(){
	ip4_firewall_flush_vpn_rules
	ip4_firewall_flush_ssr_rules
	ip4_del_guest_to_vpn_network
}
# ------------------------------------------------------------------------------------------

ip4_flush_all_tables(){

	ipset flush "${table_name}" 2>"${res_file}"
	log_result "${?}" "${app}::Очистка записей ipset таблицы ${table_name} произведена"

	ip4 route flush table "${TABLE_ID}" > "${res_file}"
	log_result "${?}" "${app}::Очистка таблицы маршрутизации ID#${TABLE_ID} произведена"

	ip4_flush_cache
}
# ------------------------------------------------------------------------------------------

ip4_add_route_table(){

	if [ -z "$(ip4 route show table ${TABLE_ID})" ]; then
		ip4 route add table ${TABLE_ID} default via ${INFACE_GW4} dev ${INFACE_ENT} 2>"${res_file}"
		log_result "${?}" "${app}::Таблица маршрутизации ${TABLE_ID} для ${INFACE_CLI} интерфейса создана"
		ip4 route show table main |grep -Ev ^default | while read -r ROUTE; do ip4 route add table ${TABLE_ID} ${ROUTE} 2>"${res_file}"; done
		log_result "${?}" "${app}::Таблица ID #${TABLE_ID} создана"
	fi
}
# ------------------------------------------------------------------------------------------

ip4_rule_set_priority(){

	if ! ip4 rule show | grep -q "fwmark ${MARK_NUM} lookup ${TABLE_ID}"  ; then
		ip4 rule add fwmark ${MARK_NUM} lookup ${TABLE_ID} priority ${PRIORITY} 2>"${res_file}"
		log_result "${?}" "${app}::Приоритет таблицы ID #${TABLE_ID} установлен в значение ${PRIORITY}"
	fi

	ip4_flush_cache
}

ip4_rule_del_priority(){

	if ip4 rule show | grep -q "fwmark ${MARK_NUM} lookup ${TABLE_ID}"  ; then
		ip4 rule del fwmark ${MARK_NUM} lookup ${TABLE_ID} priority ${PRIORITY} 2>"${res_file}"
		log_result "${?}" "${app}::Приоритет таблицы ID #${TABLE_ID} обнулен"
	fi

	ip4_flush_cache
}


# ------------------------------------------------------------------------------------------

ip4set_create_table(){
	if ipset list ${table_name} 2>&1 | grep -q 'name does not exist' ; then
		ipset create ${table_name} hash:net family inet -exist 2>"${res_file}"
		log_result "${?}" "${app}::Таблица ${table_name} для ipset IPv4 создана"
	fi
}
# ------------------------------------------------------------------------------------------

ip4_mark_vpn_network(){

	if fastnet_enabled ; then
		logger_dev "${app}::Проверка пройдена -> программное и аппаратное ускорение ПОДКЛЮЧЕНО."
		# Без отключения ускорителей fastnat и hwnat
		ip4_firewall_mark_vpn
	else
		logger_dev "${app}::Проверка пройдена -> программное и аппаратное ускорение ОТКЛЮЧЕНО!"
		# С отключением fastnat и ускорителей hwnat
		ip4_firewall_mark_rules_tcp_udp_on
	fi
#	в случае наличия гостевой сети
	if [ -n "${INFACE_GUEST_ENT}" ]; then
		ip4_add_guest_to_vpn_network
	fi
}
# ------------------------------------------------------------------------------------------
#
# 	Правила маркировки гостевого трафика
#
# ------------------------------------------------------------------------------------------
ip4_add_guest_to_vpn_network(){
	ip4save | grep "\-j MASQUERADE" | grep -q "${INFACE_GUEST_ENT}" && {
		# Маркируем трафик гостевой сети
		ip4tables PREROUTING -t nat -p udp -d "${INFACE_GUEST_GW4}" --dport ${DNS_PORT} -j DNAT --to "${INFACE_GW4}:53" 2>"${res_file}"
		ip4tables POSTROUTING -t nat -s "${GUEST_NET}" -o "${INFACE_GUEST_ENT}" -j MASQUERADE  2>>"${res_file}"
		log_result "${?}" "${app}::Маркировка гостевого трафика подключена ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}]"
	}
}

# ------------------------------------------------------------------------------------------

ip4_flush_guest_preroute_rules (){
	num_lines=$(/opt/sbin/iptables -t nat -L PREROUTING --line-numbers | grep -c "${INFACE_GUEST_GW4}")
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(/opt/sbin/iptables -t nat -L PREROUTING --line-numbers \
					| grep "${INFACE_GUEST_GW4}" \
					| cut -d" " -f1 \
					| head -1 \
					)
			/opt/sbin/iptables -t nat -D PREROUTING "${nline}" 2>"${res_file}"
		done
		log_result "${?}" "${app}::Маркировка гостевого PREROUTING трафика отключена ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}]"
	else
		logger_dev "${app}::Правила PREROUTING iptable для гостевой сети ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}] отсутствуют."
	fi
}
# ------------------------------------------------------------------------------------------

ip4_flush_guest_postroute_rules(){

	filter="$(echo ${INFACE_GUEST_GW4} | sed 's/\.1$/\.0/')/24"
	num_lines=$(/opt/sbin/iptables -t nat -L POSTROUTING --line-numbers | grep -c "${filter}")
	if [ "${num_lines}" -gt 0 ]; then
		for b in $(seq 1 ${num_lines}); do
			nline=$(/opt/sbin/iptables -t nat -L POSTROUTING --line-numbers \
					| grep "${filter}" \
					| cut -d" " -f1 \
					| head -1 \
					)
			/opt/sbin/iptables -t nat -D PREROUTING "${nline}" 2>"${res_file}"
		done
		log_result "${?}" "${app}::Маркировка гостевого POSTROUTING трафика отключена ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}]"
	else
		logger_dev "${app}::Правила POSTROUTING iptable для гостевой сети ${INFACE_GUEST_ENT} [${INFACE_GUEST_GW4}] отсутствуют."
	fi
}
# ------------------------------------------------------------------------------------------

ip4_del_guest_to_vpn_network(){
	ip4_flush_guest_preroute_rules
	ip4_flush_guest_postroute_rules
}

ip4_init_all(){
	ip4_flush_all_tables
	ip4_firewall_flush_all_rules
	ip4set_create_table
	/opt/apps/kvas/bin/main/ipset &
}
# ------------------------------------------------------------------------------------------
#
# Функции для поддержки протокола ip6
#
# ------------------------------------------------------------------------------------------
ip6() (/opt/sbin/ip -6 "$@")
ip6tables() (if ! /opt/sbin/ip6tables -C "$@" &>/dev/null; then ip6tables -A "$@"; fi)
ip6save() (/opt/sbin/ip6tables-save)

ip6set_create_table(){
	ipset create "${table_name}6" hash:net family inet6 -exist 2>"${res_file}"
	log_result "${?}" "${app}::Таблица ${table_name} для ipset IPv6 создана"
}
